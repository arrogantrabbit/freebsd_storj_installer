#!/bin/sh

# PROVIDE: storagenode
# REQUIRE: LOGIN FILESYSTEMS netwait
# KEYWORD: SHUTDOWN

. /etc/rc.subr

name=storagenode
rcvar=${name}_enable

load_rc_config $name
: "${storagenode_enable:=yes}"
: "${storagenode_executable:="/usr/local/bin/storagenode"}"
: "${storagenode_msg:="Nothing started."}"
: "${storagenode_storage_path:="/mnt/storagenode"}"
: "${storagenode_config_dir:="${storagenode_storage_path}/config"}"
: "${storagenode_identity_dir:="${storagenode_storage_path}/identity/storagenode"}"

pidfile="/var/run/${name}.pid"
command="/usr/sbin/daemon"

# Create log file with 644 permissions and storagenode as owner. Daemon utility by default uses 600
logfile="/var/log/${name}.log"
touch "${logfile}" && chown storagenode:storagenode "${logfile}" && chmod 644 "${logfile}"

command_args="-r -f -H \
  -o \"${logfile}\" \
  -P \"${pidfile}\" \
  -u storagenode \"${storagenode_executable}\" run \
    --config-dir \"${storagenode_config_dir}\" \
    --identity-dir \"${storagenode_identity_dir}\" \
    --log.output stdout \
    --storage.path \"${storagenode_storage_path}\""

# Check if storage path is mounted and accessible
command_args_pre="if [ -d \"${storagenode_storage_path}\" ] && [ -w \"${storagenode_storage_path}\" ]; then ${command_args}; else echo \"Storage path not accessible, exiting\"; exit 1; fi"

# Required directories (space-separated, quoted for spaces)
required_dirs="${storagenode_storage_path}/blobs ${storagenode_config_dir} ${storagenode_identity_dir}"

stop_cmd="${name}_stop"

${name}_stop()
{
  echo "Stopping ${name} service..."

  if [ -e "$pidfile" ]; then
    # Try graceful shutdown first
    kill -s SIGTERM `cat "$pidfile"` 2>/dev/null

    # Wait for process to exit (with timeout)
    start_time=$(date +%s)
    end_time=$(($start_time + 10))

    while [ -e "$pidfile" ] && [ $(date +%s) -lt $end_time ]; do
      kill -0 $(cat "$pidfile") 2>/dev/null && sleep 0.1
    done

    # Force kill if PID file still exists
    if [ -e "$pidfile" ]; then
      kill -s SIGKILL `cat "$pidfile"` 2>/dev/null
      # Manually remove the pidfile after a forceful kill
      rm -f "$pidfile"
      echo "${name} service force-stopped"
    fi
  else
    echo "${name} service not running"
  fi
}

run_rc_command "$1"